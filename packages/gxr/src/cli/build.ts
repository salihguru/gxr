import * as esbuild from "esbuild";
import * as fs from "fs";
import * as path from "path";

export interface BuildOptions {
  componentsDir: string;
  outputDir: string;
}

interface ClientComponent {
  name: string;
  path: string;
}

/**
 * Find all files with "use client" directive
 */
function findClientComponents(componentsDir: string): ClientComponent[] {
  const components: ClientComponent[] = [];

  if (!fs.existsSync(componentsDir)) {
    return components;
  }

  const files = fs.readdirSync(componentsDir);

  for (const file of files) {
    if (!file.endsWith(".tsx") && !file.endsWith(".ts")) continue;

    const filePath = path.join(componentsDir, file);
    const content = fs.readFileSync(filePath, "utf-8");

    // Check for "use client" directive at the start
    const trimmed = content.trimStart();
    if (trimmed.startsWith('"use client"') || trimmed.startsWith("'use client'")) {
      const name = path.basename(file, path.extname(file));
      components.push({ name, path: filePath });
    }
  }

  return components;
}

/**
 * Generate the hydration entry file
 */
function generateHydrateEntry(components: ClientComponent[], componentsDir: string): string {
  const imports = components
    .map((c) => {
      const relativePath = path.relative(path.dirname(componentsDir), c.path).replace(/\\/g, "/");
      return `import ${c.name}Component from "../${relativePath}";`;
    })
    .join("\n");

  const registry = components.map((c) => `  "${c.name}": ${c.name}Component,`).join("\n");

  return `// Auto-generated by GXR - Do not edit
import { hydrateRoot } from "react-dom/client";

${imports}

const clientComponents: Record<string, React.ComponentType<any>> = {
${registry}
};

type HydrationEntry = {
  id: number;
  component: string;
  props: any;
};

function hydrateClientComponents() {
  const dataScript = document.getElementById("__HYDRATION_DATA__");
  if (!dataScript) {
    return; // No client components on this page
  }

  let entries: HydrationEntry[];
  try {
    entries = JSON.parse(dataScript.textContent || "[]");
  } catch (err) {
    console.error("[GXR] Failed to parse hydration data:", err);
    return;
  }

  entries.forEach(({ id, component, props }) => {
    const element = document.querySelector<HTMLElement>(\`[data-hid="\${id}"]\`);
    if (!element) {
      console.warn(\`[GXR] Element with data-hid="\${id}" not found\`);
      return;
    }

    const Component = clientComponents[component];
    if (!Component) {
      console.error(\`[GXR] Component "\${component}" not found in registry\`);
      return;
    }

    try {
      hydrateRoot(element, <Component {...props} />);
    } catch (err) {
      console.error(\`[GXR] Failed to hydrate "\${component}":\`, err);
    }
  });
}

// Run hydration when DOM is ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", hydrateClientComponents);
} else {
  hydrateClientComponents();
}
`;
}

/**
 * Build client components for hydration
 */
export async function build(options: BuildOptions): Promise<void> {
  const { componentsDir, outputDir } = options;

  console.log("ðŸ” Scanning for 'use client' components...");
  const clientComponents = findClientComponents(componentsDir);

  if (clientComponents.length === 0) {
    console.log("âš ï¸  No client components found.");
    return;
  }

  console.log(`ðŸ“¦ Found ${clientComponents.length} client component(s):`);
  clientComponents.forEach((c) => console.log(`   - ${c.name}`));

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate hydration entry in a temp location
  const tempDir = path.join(outputDir, ".gxr");
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }

  const hydrateEntry = generateHydrateEntry(clientComponents, componentsDir);
  const hydrateEntryPath = path.join(tempDir, "hydrate.tsx");
  fs.writeFileSync(hydrateEntryPath, hydrateEntry);
  console.log("âœ¨ Generated hydration entry");

  // Build hydration bundle (for browser)
  await esbuild.build({
    entryPoints: [hydrateEntryPath],
    bundle: true,
    outfile: path.join(outputDir, "hydrate.js"),
    format: "esm",
    target: "es2020",
    jsx: "automatic",
    minify: process.env.NODE_ENV === "production",
    sourcemap: process.env.NODE_ENV !== "production",
  });
  console.log("âœ… Built hydrate.js");

  console.log("\nðŸŽ‰ Build complete!");
}
