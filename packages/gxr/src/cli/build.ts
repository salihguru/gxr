import * as esbuild from "esbuild";
import * as fs from "fs";
import * as path from "path";

export interface BuildOptions {
  componentsDir: string;
  outputDir: string;
}

interface ClientComponent {
  name: string;
  path: string;
  /** The unique identifier used for the import variable */
  importName: string;
}

/**
 * Check if a filename is a React/TypeScript file
 */
function isReactFile(filename: string): boolean {
  return filename.endsWith(".tsx") || filename.endsWith(".ts");
}

/**
 * Check if a file has the "use client" directive at the start.
 * Handles various edge cases:
 * - Semicolon after directive (e.g., "use client";)
 * - BOM markers (UTF-8 BOM from Windows editors)
 * - Various quote styles and whitespace
 */
function hasUseClientDirective(filePath: string): boolean {
  const content = fs.readFileSync(filePath, "utf-8");
  
  // Remove BOM if present (common in files from Windows editors)
  const cleanContent = content.replace(/^\uFEFF/, "");
  
  // Pattern: Start of file, optional whitespace, matching quotes around "use client", 
  // optional semicolon, followed by whitespace/newline or end
  // Using backreference (\1) to ensure opening and closing quotes match
  const useClientPattern = /^\s*(["'])use client\1\s*;?\s*(?:\n|$)/;
  
  return useClientPattern.test(cleanContent);
}

/**
 * Generate a unique import name for a component to avoid collisions
 * when components with the same name exist in different directories.
 * e.g., "forms/Button" -> "FormsButton", "Button" -> "Button"
 */
// Helper to sanitize a string to a valid JS identifier (PascalCase, no invalid chars, no leading digit)
function sanitizeIdentifier(str: string): string {
  // Remove invalid characters, split on non-alphanumeric, capitalize each part, join
  const parts = str.split(/[^a-zA-Z0-9]/).filter(Boolean);
  let id = parts.map(part => part.charAt(0).toUpperCase() + part.slice(1)).join("");
  // If starts with digit, prefix with underscore
  if (/^[0-9]/.test(id)) {
    id = "_" + id;
  }
  return id;
}

function generateUniqueImportName(relativePath: string, filename: string): string {
  const baseName = sanitizeIdentifier(path.basename(filename, path.extname(filename)));
  
  if (!relativePath) {
    return baseName;
  }
  
  // Convert path segments to PascalCase, sanitize, and combine with component name
  const pathParts = relativePath.split(path.sep).filter(Boolean);
  const pathPrefix = pathParts
    .map(part => sanitizeIdentifier(part))
    .join("");
  
  return pathPrefix + baseName;
}

/**
 * Recursively find all files with "use client" directive in a directory.
 * Handles nested component directories and avoids hidden files/folders.
 */
function findClientComponentsRecursive(
  dir: string,
  baseDir: string,
  relativePath: string = ""
): ClientComponent[] {
  const components: ClientComponent[] = [];

  if (!fs.existsSync(dir)) {
    return components;
  }

  const entries = fs.readdirSync(dir, { withFileTypes: true });

  for (const entry of entries) {
    // Skip hidden files and directories
    if (entry.name.startsWith(".")) continue;

    const fullPath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      // Recursively scan subdirectories
      const newRelativePath = path.join(relativePath, entry.name);
      components.push(
        ...findClientComponentsRecursive(fullPath, baseDir, newRelativePath)
      );
    } else if (entry.isFile() && isReactFile(entry.name)) {
      if (hasUseClientDirective(fullPath)) {
        const baseName = path.basename(entry.name, path.extname(entry.name));
        const importName = generateUniqueImportName(relativePath, entry.name);
        
        components.push({
          name: baseName,
          path: fullPath,
          importName,
        });
      }
    }
  }

  return components;
}

/**
 * Find all files with "use client" directive (wrapper for backward compatibility)
 */
function findClientComponents(componentsDir: string): ClientComponent[] {
  return findClientComponentsRecursive(componentsDir, componentsDir);
}

/**
 * Generate the hydration entry file
 */
function generateHydrateEntry(components: ClientComponent[], hydrateDir: string): string {
  const imports = components
    .map((c) => {
      const relativePath = path.relative(hydrateDir, c.path).replace(/\\/g, "/");
      // Use unique importName to avoid collisions between components with same base name
      return `import ${c.importName}Component from "${relativePath}";`;
    })
    .join("\n");

  // Registry maps component base names to their imported components
  const registry = components.map((c) => `  "${c.name}": ${c.importName}Component,`).join("\n");

  return `// Auto-generated by GXR - Do not edit
import { hydrateRoot } from "react-dom/client";
import type { ComponentType } from "react";

${imports}

// Registry of client components for hydration
// Using 'any' for props as they come from JSON.parse() of server-rendered data
const clientComponents: Record<string, ComponentType<Record<string, unknown>>> = {
${registry}
};

type HydrationEntry = {
  id: number;
  component: string;
  props: any;
};

function hydrateClientComponents() {
  const dataScript = document.getElementById("__HYDRATION_DATA__");
  if (!dataScript) {
    return; // No client components on this page
  }

  let entries: HydrationEntry[];
  try {
    entries = JSON.parse(dataScript.textContent || "[]");
  } catch (err) {
    console.error("[GXR] Failed to parse hydration data:", err);
    return;
  }

  entries.forEach(({ id, component, props }) => {
    const element = document.querySelector<HTMLElement>(\`[data-hid="\${id}"]\`);
    if (!element) {
      console.warn(\`[GXR] Element with data-hid="\${id}" not found\`);
      return;
    }

    const Component = clientComponents[component];
    if (!Component) {
      console.error(\`[GXR] Component "\${component}" not found in registry\`);
      return;
    }

    try {
      hydrateRoot(element, <Component {...props} />);
    } catch (err) {
      console.error(\`[GXR] Failed to hydrate "\${component}":\`, err);
    }
  });
}

// Run hydration when DOM is ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", hydrateClientComponents);
} else {
  hydrateClientComponents();
}
`;
}

/**
 * Build client components for hydration
 */
export async function build(options: BuildOptions): Promise<void> {
  const { componentsDir, outputDir } = options;

  console.log("üîç Scanning for 'use client' components...");
  const clientComponents = findClientComponents(componentsDir);

  if (clientComponents.length === 0) {
    console.log("‚ö†Ô∏è  No client components found.");
    console.log("   Make sure your components have \"use client\" at the top of the file.");
    return;
  }

  console.log(`üì¶ Found ${clientComponents.length} client component(s):`);
  clientComponents.forEach((c) => {
    // Show relative path for better debugging with nested directories
    const relativePath = path.relative(componentsDir, c.path);
    console.log(`   - ${relativePath}`);
  });

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate hydration entry in a temp location
  const tempDir = path.join(outputDir, ".gxr");
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }

  const hydrateEntry = generateHydrateEntry(clientComponents, tempDir);
  const hydrateEntryPath = path.join(tempDir, "hydrate.tsx");
  fs.writeFileSync(hydrateEntryPath, hydrateEntry);
  console.log("‚ú® Generated hydration entry");

  // Build hydration bundle (for browser)
  try {
    await esbuild.build({
      entryPoints: [hydrateEntryPath],
      bundle: true,
      outfile: path.join(outputDir, "hydrate.js"),
      format: "esm",
      target: "es2020",
      jsx: "automatic",
      minify: process.env.NODE_ENV === "production",
      sourcemap: process.env.NODE_ENV !== "production",
      logLevel: "warning",
    });
    console.log("‚úÖ Built hydrate.js");
  } catch (error) {
    console.error("\n‚ùå Build failed!\n");
    
    if (error instanceof Error) {
      // esbuild errors are already formatted, but we add helpful context
      console.error("Common causes:");
      console.error("   - Missing peer dependencies (react, react-dom)");
      console.error("   - Invalid JSX/TSX syntax in client components");
      console.error("   - Missing default export in component file");
      console.error("   - Import errors in your components\n");
    }
    
    throw error;
  }

  console.log("\nüéâ Build complete!");
}
